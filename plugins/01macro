#

package macro;

#open my($f), ">>", "/dev/pts/13";
open my($f), ">", "/tmp/macro-$<";

my %basemacro = ();

sub start {
  my $macros = "$blosxom::plugin_state_dir/macros";
    if (open my($mac), "<", $macros) {
      print $f "loading global macro file '$macros'\n";
      while (<$mac>) {
	chomp;
	if (/^#define\s+(\S+)\s+(.*)$/) {
	  print $f "<$1> => <$2>\n";
	  $basemacro{$1} = $2;
	} elsif (/\S/) {
	  print $f "unparseable line $. : $_\n";
	}
      }
      my $N = keys %basemacro;
      print $f "defined $N global macros total\n";
      return 1;
    } else {
      my $eno = $!{ENOENT};
      print $f "couldn't load base macro file '$macros': $!\n";
      return $eno ? 1 : 0;  # ENOENT is a continuable error
    }
}

sub story {
  my ($pkg, $path, $filename, $story_ref, $title_ref, $body_ref) = @_;

  my @lines = split /\n/, $$body_ref;
  my %macro = %basemacro;
  my %escape;
  my $MACPAT = join "|", map quotemeta, keys %macro;
  for (@lines) {
    if (/^#define\s+(\S+)\s+(.*)$/) {
      print $f "<$1> => <$2>\n";
      $macro{$1} = $2;
      $MACPAT = join "|", map quotemeta, keys %macro;
      print $f "Pattern: $MACPAT\n";
      $_ = "";
      next;
    } elsif (/^#undefall\s*/) {
      %macro = ();
      $MACPAT = "";
      print $f "Pattern: $MACPAT\n";
      $_ = "";
    }       
#    for my $m (keys %macro) {
      my $old = $_;
      s/($MACPAT)/$macro{$1}/g;
      print $f "  $old\n  $_\n\n" if $old ne $_;
#    }
  }

  $$body_ref = join "\n", @lines;
  return 1;
}

1;
