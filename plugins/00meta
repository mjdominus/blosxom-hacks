# -*- cperl -*-

package meta;
use lib '/home/mjd/misc/blog/src/lib';
use Blosxom::MJD::Meta;
use strict;
use Fcntl qw(O_RDWR O_CREAT LOCK_EX);

# metainformation examples:
#  tags
#  title
#  not-yet flag

my $metadb = "$blosxom::plugin_state_dir/META";
open my($f), ">", "/tmp/meta.$<";
print $f "Starting at " . localtime() . "\n";
print $f "Tie::File:Hash version $Tie::File::Hash::VERSION\n";
our %metadb;
our $META;

sub start {
  $META = Blosxom::MJD::Meta->new($metadb, { debug => $f });
  *metadb = *blosxom::META = $META->hash;

  print $f "meta plugin tied $metadb\n";
  return 1;
}

sub end {
  print $f "Untying\n";
  untie %metadb;
  undef $META;
  close $f;
}

sub story {
  my ($pkg, $path, $filename, $story_ref, $title_ref, $body_ref, $fullpath)
    = @_;
  my $BAD;

  print $f "meta plugin processing <$path/$filename>\n";
  return unless $$title_ref =~ /\A\s*META\s*\z/;
  print $f "Found meta section in <$path/$filename>\n";

  my %meta = (HAS => 1);
  {
    my @body = split /\n/, $$body_ref;
    my @meta;
    push @meta, shift @body while @body && $body[0] =~ /\S/;
    shift @body;
    $$body_ref = join "\n", @body;
    print $f "$path/$filename: found " . @meta . " meta-lines\n";
    for (@meta) {
      print $f "  $_\n";
      s/\s+\z//;
      my ($k, $v) = split /:\s+/, $_, 2;
      $meta{lc $k} = $v;
      print $f "  $k => $v\n";
    }
  };

  $$title_ref = $meta{"title"} || do {
    warn "file $path/$filename has no title in its META section\n";
    $BAD++;
    "(no title in META section)";
  };

  $META->store_metadata("$path/$filename", \%meta);
  my %tied;
  my $obj = tie %tied, 'Metadata', "$path/$filename";
  $blosxom::metadata_hash{"$path/$filename"} = \%tied;
  $blosxom::metadata_obj{"$path/$filename"} = $obj;

  return $BAD ? 0 : 1;
}

END {
  print $f "Exiting at " . localtime() . "\n";
}

package Metadata;
use Carp qw(confess croak);

sub TIEHASH {
  my ($class, $article) = @_;
  bless { article => $article } => $class;
}

sub FETCH {
  my ($self, $k) = @_;
  meta::get($self->{article}, $k);
}

sub EXISTS {
  my ($self, $k) = @_;
  meta::has($self->{article}, $k);
}

sub STORE {
  croak "STORE unimplemented";
}

sub FIRSTKEY {
  my ($self) = @_;
  $self->{keys} = [ meta::get_metadata_items($self->{article}) ];
  return shift @{$self->{keys}};
}

sub NEXTKEY {
  my ($self) = @_;
  return shift @{$self->{keys}};
}

1;

