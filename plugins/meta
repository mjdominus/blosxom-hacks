# -*- cperl -*-

package meta;
use DB_File;

# metainformation examples:
#  tags
#  title
#  not-yet flag

my $metadb = "$blosxom::plugin_state_dir/META";
open my($f), ">>", "/tmp/meta.$<";

sub start { 
  tie my(%metadb) => 'Tie::File::Hash' => $metadb,
    { mode => O_RDWR | O_CREAT }
      or die "Couldn't tie $metadb: $!";
  return 1;
}

sub story {
  my ($pkg, $path, $filename, $story_ref, $title_ref, $body_ref, $fullpath)
    = @_;
  my $BAD;

  return unless $$title_ref =~ /\A\s*META\s*\z/;
  print $f "Found meta section in <$path/$filename>\n";

  my %meta;
  {
    my @body = split /\n/, $$body_ref;
    my @meta;
    push @meta, shift @body while @body && $body[0] =~ /\S/;
    shift @body;
    $$body_ref = join "\n", @body;
    print $f "$path/$filename: found " . @meta . " meta-lines\n";
    for (@meta) {
      print $f "  $_\n";
      s/\s+\z//;
      my ($k, $v) = split /:\s+/, $_, 2;
      $meta{$k} = $v;
    }
  };

  $$title_ref = $meta{"title"} or do {
    warn "file $path/$filename has no title in its META section\n";
    $BAD++;
    "(no title in META section)";
  };

  return $BAD ? 0 : 1;
}

sub store_metadata {
  my ($key, $md) = @_;
  delete_metadata($key);
  put_metadata_items($key, $md);
  while (my ($k, $v) = each %$md) {
    $metadb{meta_key($key, $k)} = $v;
  }
}

sub delete_metadata {
  my ($key) = @_;
  my @items = get_metadata_items($key);
  return unless @items;
  for my $item (@items) {
    delete $metadb{meta_key($key, $item)};
  }
}

sub get_metadata_items {
  my ($key) = @_;
  my $v = $metadb{meta_key($key, "")};
  split /,\s*/, $v;
}

sub put_metadata_items {
  my ($key, $h) = @_;
  $metadb{meta_key($key, "")} = join "," => sort keys %$h;
}

sub meta_key {
  my ($key, $item) = @_;
  return $key unless defined($item) && length($item) > 0;
  return join "::", $key, $item;
}

sub trim {
  $_[0] =~ s/^\s+//;
  $_[0] =~ s/\s+$//;
  return $_[0];
}

1;

